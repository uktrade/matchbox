"""Objects to define a DAG which indexes, deduplicates and links data."""

import datetime
from abc import ABC, abstractmethod
from enum import StrEnum
from typing import Any, Literal

from pydantic import BaseModel, Field, field_validator, model_validator
from sqlglot import errors, expressions, parse_one

from matchbox.common.graph import ResolutionName
from matchbox.common.sources import SourceConfig


class DeduperClass(StrEnum):
    """Enumeration of deduper types."""

    NAIVE = "naive"


class LinkerClass(StrEnum):
    """Enumeration of linker types."""

    DETERMINISTIC = "deterministic"
    WEIGHTED_DETERMINISTIC = "weighted_deterministic"
    SPLINK = "splink"


class Step(BaseModel, ABC):
    """Abstract base class defining what a step needs to support."""

    name: ResolutionName
    sources: set[str] = Field(default_factory=set)
    last_run: datetime.datetime | None = Field(default=None)

    @property
    @abstractmethod
    def inputs(self) -> list["StepInput"]:
        """Return all inputs to this step."""
        ...


class StepInput(BaseModel):
    """Input to a DAG step, generated by a previous node in the DAG."""

    prev_node: Step
    select: dict[SourceConfig, list[str]]
    cleaning_dict: dict[str, str] | None = None
    batch_size: int | None = None
    threshold: float | None = None
    combine_type: Literal["concat", "explode", "set_agg"] = "concat"

    @property
    def name(self) -> str:
        """Resolution name for node generating this input for the next step."""
        return self.prev_node.name

    @field_validator("cleaning_dict")
    @classmethod
    def validate_cleaning_dict(cls, v: dict[str, str] | None) -> str | None:
        """Validate cleaning as valid SQL."""
        if v is None:
            return v

        for alias, sql in v.items():
            if sql is not None:
                try:
                    stmt = parse_one(sql, dialect="duckdb")
                except errors.ParseError as e:
                    raise ValueError(f"Invalid SQL in cleaning_dict: {alias}") from e

                for node in stmt.walk():
                    if isinstance(node, expressions.Column) and node.name == "id":
                        raise ValueError(
                            "Cannot transform 'id' column in cleaning_dict. "
                            "It is always selected by default."
                        )

        return v

    @model_validator(mode="after")
    def validate_all_input(self) -> "StepInput":
        """Verify select statement is valid given previous node."""
        if isinstance(self.prev_node, IndexStep):
            if (
                len(self.select) > 1
                or list(self.select.keys())[0] != self.prev_node.source_config
            ):
                raise ValueError(
                    f"Can only select from source {self.prev_node.source_config.name}"
                )
        else:
            for source in self.select:
                if str(source.name) not in self.prev_node.sources:
                    raise ValueError(
                        f"Cannot select {source.name} from {self.prev_node.name}."
                        f"Available sources are {self.prev_node.sources}."
                    )
        return self


class IndexStep(Step):
    """Index step."""

    source_config: SourceConfig
    batch_size: int | None = Field(default=None)

    @model_validator(mode="before")
    @classmethod
    def source_to_attributes(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Convert source config to name and sources attributes."""
        if "source_config" not in data:
            raise ValueError("SourceConfig must be provided")

        if not isinstance(data["source_config"], SourceConfig):
            raise ValueError("SourceConfig must be of type SourceConfig")

        data["name"] = str(data["source_config"].name)
        data["sources"] = {str(data["source_config"].name)}
        return data

    @property
    def inputs(self) -> list[StepInput]:
        """Return all inputs to this step."""
        return []


class ModelStep(Step):
    """Base class for model steps."""

    description: str
    left: StepInput
    settings: dict[str, Any]
    truth: float

    @model_validator(mode="after")
    def init_sources(self) -> "ModelStep":
        """Add sources inherited from all inputs."""
        for step_input in self.inputs:
            self.sources.update(step_input.prev_node.sources)

        return self


class DedupeStep(ModelStep):
    """Deduplication step."""

    model_class: DeduperClass

    @property
    def inputs(self) -> list[StepInput]:
        """Return all inputs to this step."""
        return [self.left]


class LinkStep(ModelStep):
    """Linking step."""

    model_class: LinkerClass
    right: StepInput

    @property
    def inputs(self) -> list[StepInput]:
        """Return all `StepInputs` to this step."""
        return [self.left, self.right]


class DAG:
    """Well-defined pipeline of indexing, deduping and linking steps."""

    def __init__(self):
        """Initialise DAG object."""
        self.nodes: dict[ResolutionName, Step] = {}
        self.graph: dict[ResolutionName, list[ResolutionName]] = {}

    def _validate_node(self, name: ResolutionName) -> None:
        """Validate that a node name is unique in the DAG."""
        if name in self.nodes:
            raise ValueError(f"Name '{name}' is already taken in the DAG")

    def _validate_inputs(self, step: Step) -> None:
        """Validate that all inputs to a step are already in the DAG."""
        for step_input in step.inputs:
            if step_input.name not in self.nodes:
                raise ValueError(f"Dependency {step_input.name} not added to DAG")

    def add_sources(
        self, *source_configs: SourceConfig, batch_size: int | None = None
    ) -> tuple[IndexStep]:
        """Add sources to DAG.

        Args:
            source_configs: All sources to add.
            batch_size: Batch size for indexing.
        """
        index_steps = tuple(
            IndexStep(source_config=source_config, batch_size=batch_size)
            for source_config in source_configs
        )
        self.add_steps(*index_steps)
        return index_steps

    def add_steps(self, *steps: Step) -> None:
        """Add dedupers and linkers to DAG, and register sources available to steps.

        Args:
            steps: Dedupe and link steps.
        """
        for step in steps:
            self._validate_node(step.name)
            self._validate_inputs(step)
            self.nodes[step.name] = step
            self.graph[step.name] = [step_input.name for step_input in step.inputs]
